'''This gathers information about the random number generator function so that it can be seeded to give any particular
series of virtual coin tosses up to a certain length.
'''
import random

FAIR_COIN = lambda: random.randint(0, 1)
RANDOM_SEED = random.seed

# class SeedTree(object):
#     """A binary tree that, at each node, has the seed value to use for
#     random.seed() to obtain the sequence of head/tail tosses to get to that
#     node.
#     seed() will give the appropriate seed that will create a specific
#     sequence of coin tosses.
#
#     Construction time is probabilistic and broadly exponential.
#     Typically, for depths 10 to 14 the construction time for fair coins is:
#     Depth    t(s)
#       10    0.380
#       11    4.780
#       12    6.320
#       13   22.650
#       14  287.680
#
#     For non-fair coins this can increase dramatically.
#     """
#     def __init__(self, seed, depth, fn=FAIR_COIN):
#         self._seed = seed
#         self._head = None
#         self._tail = None
#         self.add(seed, depth, fn)
#
#     def complete(self, depth):
#         """True if we have found the seeds for every head/tail sequence of
#         length depth."""
#         if depth == 0:
#             return True
#         if self._head is None or self._tail is None:
#             return False
#         return self._head.complete(depth - 1) and self._tail.complete(depth - 1)
#
#     def add(self, seed, depth, fn):
#         """Create and add a sequence of head/tail tosses of length depth for the given
#         seed.
#         It is assumed that random.seed(seed) has been called immediately before
#         this call."""
#         if depth:
#             toss = fn()
#             if toss:
#                 if self._head is None:
#                     self._head = SeedTree(seed, depth - 1, fn)
#                 else:
#                     self._head.add(seed, depth - 1, fn)
#             else:
#                 if self._tail is None:
#                     self._tail = SeedTree(seed, depth - 1, fn)
#                 else:
#                     self._tail.add(seed, depth - 1, fn)
#
#     def seed(self, tosses):
#         """Returns the seed required to achieve the sequence of
#         head/tail tosses."""
#         if len(tosses):
#             if tosses[0]:
#                 if self._head is None:
#                     raise ValueError('Length of tosses exceeds number of throws I was built for.')
#                 return self._head.seed(tosses[1:])
#             else:
#                 if self._tail is None:
#                     raise ValueError('Length of tosses exceeds number of throws I was built for.')
#                 return self._tail.seed(tosses[1:])
#         else:
#             return self._seed
#
#     @classmethod
#     def create(cls, depth, seed_fn, toss_fn):
#         """Creates a SeedTree of the required depth using two functions:
#         seed_fn - The function to call with an integer to seed the random number generator.
#         toss_fn - The function to call to toss a coin.
#
#         For example, using the Python random number generator:
#         seed_fn=random.seed
#         toss_fn=lambda: random.randint(0, 1)
#         """
#         seed = 0
#         seed_fn(seed)
#         tree = cls(seed, depth, toss_fn)
#         while not tree.complete(depth):
#             seed += 1
#             seed_fn(seed)
#             tree.add(seed, depth, toss_fn)
#         return tree


def has_all_sequences(seeds_for_sequences, length):
    """Return True if we have all permutations up to the length specified.

    """
    sequence_count_needed = 2 ** (length + 1) - 2
    return len(seeds_for_sequences) == sequence_count_needed


def sequence_for_seed(rand_func, seed_func, seed_val, length):
    """Return a list of booleans generated by rand_func after seeding.

    """
    seed_func(seed_val)
    return [rand_func() for _ in range(length)]


def find_seeds_for_sequences(max_length, seed_func, rand_func):
    """Return a dict mapping sequences to the random seed required to
    generate them.

    >>> find_seeds_for_sequences(FAIR_COIN, RANDOM_SEED, 2)
    {(0,): 1, (0, 0): 9, (0, 1): 8, (1,): 0, (1, 0): 10, (1, 1): 6}

    """
    seeds_for_sequences = {}

    for length in range(1, max_length + 1):
        seed_val = 0
        while not has_all_sequences(seeds_for_sequences, length):
            sequence = sequence_for_seed(rand_func, seed_func, seed_val, length)
            seeds_for_sequences[tuple(sequence)] = seed_val

            seed_val += 1

    return seeds_for_sequences


